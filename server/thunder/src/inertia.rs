use std::fs;

use once_cell::sync::Lazy;
//use salvo::http::{header, Mime};
use salvo::{
    Depot, Request, Response, Writer, async_trait,
    http::{HeaderValue, header},
    oapi::{Components, EndpointOutRegister, Operation, ToSchema},
    writing::Text,
};
use serde::Serialize;
use serde_json::json;
use tera::{Context, Tera};

use sha2::{Digest, Sha256};

use crate::tera_helpers; // Import hashing tools

// This is where the magic happens. We teach Salvo how to render our `Inertia` struct.
#[async_trait]
impl<T: Serialize + Send + salvo::prelude::ToSchema> Writer for Inertia<T> {
    async fn write(mut self, req: &mut Request, depot: &mut Depot, res: &mut Response) {
        let tera: &tera::Tera = &tera_helpers::TERA_ENGINE;
        // 2. Define a static asset version. In a real app, this might come from a file hash or env var.
        let version = ASSET_VERSION.to_string();

        // 3. Construct the full Page object.
        let page = Page {
            component: self.component,
            props: self.props,
            url: req
                .uri()
                .path_and_query()
                .map(|pq| pq.as_str())
                .unwrap_or("/")
                .to_string(),
            version,
        };

        // 4. Check for the `X-Inertia` header to determine the response type.
        if req.headers().get("X-Inertia").is_some() {
            // It's an Inertia visit: respond with JSON.
            res.headers_mut().insert(
                header::CONTENT_TYPE,
                HeaderValue::from_static("application/json"),
            );
            res.headers_mut()
                .insert("X-Inertia", "true".parse().unwrap());
            res.render(salvo::prelude::Json(page));
        } else {
            // It's a first-time visit: respond with the full HTML shell.
            let mut context = Context::new();
            // Serialize the page data to a JSON string to embed in the HTML.
            let page_json = json!(page).to_string();
            context.insert("page", &page_json);
            context.insert("is_development", &*IS_DEVELOPMENT);

            if !(*IS_DEVELOPMENT) {
                // In production, read the manifest and inject asset paths.
                // NOTE: This is a simplified example. You should read and parse the manifest
                // only once at server startup for efficiency.
                let manifest_str = std::fs::read_to_string("public/assets/.vite/manifest.json")
                    .expect("Failed to read manifest.json. Did you run `bun run build`?");

                let manifest: serde_json::Value =
                    serde_json::from_str(&manifest_str).expect("Failed to parse manifest.json");

                // Assuming your entrypoint is `resources/ts/app.ts`
                let entry = &manifest["resources/ts/app.ts"];
                if let (Some(js), Some(css)) = (entry["file"].as_str(), entry["css"][0].as_str()) {
                    context.insert("js_path", &format!("/assets/{}", js));
                    context.insert("css_path", &format!("/assets/{}", css));
                }
            }

            match tera.render("index.html", &context) {
                Ok(html) => res.render(Text::Html(html)),
                Err(e) => {
                    res.status_code(salvo::http::StatusCode::INTERNAL_SERVER_ERROR);
                    res.render(format!("Template rendering error: {}", e));
                }
            }
        }
    }
}

// V-- NEW: LAZY STATIC FOR ASSET VERSION --V
pub static ASSET_VERSION: Lazy<String> = Lazy::new(|| {
    // Path to the manifest file generated by Vite.
    const MANIFEST_PATH: &str = "frontend/dist/.vite/manifest.json";

    if *IS_DEVELOPMENT {
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs()
            .to_string()
    } else {
        match fs::read_to_string(MANIFEST_PATH) {
            Ok(content) => {
                // If the file exists, create a SHA256 hash of its content.
                let mut hasher = Sha256::new();
                hasher.update(content.as_bytes());
                let hash_result = hasher.finalize();
                // Convert the hash to a hex string to use as the version.
                hex::encode(hash_result)
            }
            Err(_) => {
                // Fallback for development: if the manifest doesn't exist,
                // use the current timestamp to force reloads on every server restart.
                eprintln!(
                    "Error: Could not find manifest file at '{}'. Falling back to timestamp-based asset version.",
                    MANIFEST_PATH
                );
                std::time::SystemTime::now()
                    .duration_since(std::time::UNIX_EPOCH)
                    .unwrap()
                    .as_secs()
                    .to_string()
            }
        }
    }
});

pub static IS_DEVELOPMENT: Lazy<bool> = Lazy::new(|| {
    return cfg!(debug_assertions);
});

// pub fn init_thunder(){
//
//
//
// }

// The main Inertia page object that gets sent to the client.
#[derive(Serialize)]
pub struct Page<T: Serialize + Send> {
    component: String,
    props: T,
    url: String,
    version: String,
}

// Our custom responder struct.
pub struct Inertia<T: Serialize + ToSchema + Send> {
    component: String,
    props: Option<T>,
}

impl<T: Serialize> Inertia<T>
where
    T: ToSchema + Send + Serialize,
{
    pub fn new(component: impl Into<String>, props: T) -> Self {
        Self {
            component: component.into(),
            props: Some(props),
        }
    }

    pub fn new_no_props(component: impl Into<String>) -> Self {
        Self {
            component: component.into(),
            props: None,
        }
    }
}

// impl<T: salvo::oapi::EndpointOutRegister> for Inertia<T>
// where
//     T: Serialize + ToSchema + Send,
// {
//     fn register(components: &mut salvo::oapi::Components, operation: &mut salvo::oapi::Operation) {
//         todo!()
//     }
// }
impl<T> EndpointOutRegister for Inertia<T>
where
    T: Serialize + ToSchema + Send,
{
    fn register(components: &mut Components, operation: &mut Operation) {
        let response = salvo::oapi::Response::new("desc");
        // T::register(components);
        // operation.responses.insert(
        //     "200",
        //     salvo::oapi::Response {
        //         description: todo!(),
        //         headers: todo!(),
        //         contents: todo!(),
        //         extensions: todo!(),
        //         links: todo!(),
        //     },
        // );
        operation.responses.insert("200", response);
    }
}
